{"ast":null,"code":"'use strict';\n\nimport stream from 'stream';\nimport utils from '../utils.js';\nconst kInternals = Symbol('internals');\nclass AxiosTransformStream extends stream.Transform {\n  constructor(options) {\n    options = utils.toFlatObject(options, {\n      maxRate: 0,\n      chunkSize: 64 * 1024,\n      minChunkSize: 100,\n      timeWindow: 500,\n      ticksRate: 2,\n      samplesCount: 15\n    }, null, (prop, source) => {\n      return !utils.isUndefined(source[prop]);\n    });\n    super({\n      readableHighWaterMark: options.chunkSize\n    });\n    const internals = this[kInternals] = {\n      timeWindow: options.timeWindow,\n      chunkSize: options.chunkSize,\n      maxRate: options.maxRate,\n      minChunkSize: options.minChunkSize,\n      bytesSeen: 0,\n      isCaptured: false,\n      notifiedBytesLoaded: 0,\n      ts: Date.now(),\n      bytes: 0,\n      onReadCallback: null\n    };\n    this.on('newListener', event => {\n      if (event === 'progress') {\n        if (!internals.isCaptured) {\n          internals.isCaptured = true;\n        }\n      }\n    });\n  }\n  _read(size) {\n    const internals = this[kInternals];\n    if (internals.onReadCallback) {\n      internals.onReadCallback();\n    }\n    return super._read(size);\n  }\n  _transform(chunk, encoding, callback) {\n    const internals = this[kInternals];\n    const maxRate = internals.maxRate;\n    const readableHighWaterMark = this.readableHighWaterMark;\n    const timeWindow = internals.timeWindow;\n    const divider = 1000 / timeWindow;\n    const bytesThreshold = maxRate / divider;\n    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;\n    const pushChunk = (_chunk, _callback) => {\n      const bytes = Buffer.byteLength(_chunk);\n      internals.bytesSeen += bytes;\n      internals.bytes += bytes;\n      internals.isCaptured && this.emit('progress', internals.bytesSeen);\n      if (this.push(_chunk)) {\n        process.nextTick(_callback);\n      } else {\n        internals.onReadCallback = () => {\n          internals.onReadCallback = null;\n          process.nextTick(_callback);\n        };\n      }\n    };\n    const transformChunk = (_chunk, _callback) => {\n      const chunkSize = Buffer.byteLength(_chunk);\n      let chunkRemainder = null;\n      let maxChunkSize = readableHighWaterMark;\n      let bytesLeft;\n      let passed = 0;\n      if (maxRate) {\n        const now = Date.now();\n        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {\n          internals.ts = now;\n          bytesLeft = bytesThreshold - internals.bytes;\n          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;\n          passed = 0;\n        }\n        bytesLeft = bytesThreshold - internals.bytes;\n      }\n      if (maxRate) {\n        if (bytesLeft <= 0) {\n          // next time window\n          return setTimeout(() => {\n            _callback(null, _chunk);\n          }, timeWindow - passed);\n        }\n        if (bytesLeft < maxChunkSize) {\n          maxChunkSize = bytesLeft;\n        }\n      }\n      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {\n        chunkRemainder = _chunk.subarray(maxChunkSize);\n        _chunk = _chunk.subarray(0, maxChunkSize);\n      }\n      pushChunk(_chunk, chunkRemainder ? () => {\n        process.nextTick(_callback, null, chunkRemainder);\n      } : _callback);\n    };\n    transformChunk(chunk, function transformNextChunk(err, _chunk) {\n      if (err) {\n        return callback(err);\n      }\n      if (_chunk) {\n        transformChunk(_chunk, transformNextChunk);\n      } else {\n        callback(null);\n      }\n    });\n  }\n}\nexport default AxiosTransformStream;","map":{"version":3,"names":["stream","utils","kInternals","Symbol","AxiosTransformStream","Transform","constructor","options","toFlatObject","maxRate","chunkSize","minChunkSize","timeWindow","ticksRate","samplesCount","prop","source","isUndefined","readableHighWaterMark","internals","bytesSeen","isCaptured","notifiedBytesLoaded","ts","Date","now","bytes","onReadCallback","on","event","_read","size","_transform","chunk","encoding","callback","divider","bytesThreshold","Math","max","pushChunk","_chunk","_callback","Buffer","byteLength","emit","push","process","nextTick","transformChunk","chunkRemainder","maxChunkSize","bytesLeft","passed","setTimeout","subarray","transformNextChunk","err"],"sources":["C:/Users/thesh/Desktop/Authentication/frontend/node_modules/axios/lib/helpers/AxiosTransformStream.js"],"sourcesContent":["'use strict';\n\nimport stream from 'stream';\nimport utils from '../utils.js';\n\nconst kInternals = Symbol('internals');\n\nclass AxiosTransformStream extends stream.Transform{\n  constructor(options) {\n    options = utils.toFlatObject(options, {\n      maxRate: 0,\n      chunkSize: 64 * 1024,\n      minChunkSize: 100,\n      timeWindow: 500,\n      ticksRate: 2,\n      samplesCount: 15\n    }, null, (prop, source) => {\n      return !utils.isUndefined(source[prop]);\n    });\n\n    super({\n      readableHighWaterMark: options.chunkSize\n    });\n\n    const internals = this[kInternals] = {\n      timeWindow: options.timeWindow,\n      chunkSize: options.chunkSize,\n      maxRate: options.maxRate,\n      minChunkSize: options.minChunkSize,\n      bytesSeen: 0,\n      isCaptured: false,\n      notifiedBytesLoaded: 0,\n      ts: Date.now(),\n      bytes: 0,\n      onReadCallback: null\n    };\n\n    this.on('newListener', event => {\n      if (event === 'progress') {\n        if (!internals.isCaptured) {\n          internals.isCaptured = true;\n        }\n      }\n    });\n  }\n\n  _read(size) {\n    const internals = this[kInternals];\n\n    if (internals.onReadCallback) {\n      internals.onReadCallback();\n    }\n\n    return super._read(size);\n  }\n\n  _transform(chunk, encoding, callback) {\n    const internals = this[kInternals];\n    const maxRate = internals.maxRate;\n\n    const readableHighWaterMark = this.readableHighWaterMark;\n\n    const timeWindow = internals.timeWindow;\n\n    const divider = 1000 / timeWindow;\n    const bytesThreshold = (maxRate / divider);\n    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;\n\n    const pushChunk = (_chunk, _callback) => {\n      const bytes = Buffer.byteLength(_chunk);\n      internals.bytesSeen += bytes;\n      internals.bytes += bytes;\n\n      internals.isCaptured && this.emit('progress', internals.bytesSeen);\n\n      if (this.push(_chunk)) {\n        process.nextTick(_callback);\n      } else {\n        internals.onReadCallback = () => {\n          internals.onReadCallback = null;\n          process.nextTick(_callback);\n        };\n      }\n    }\n\n    const transformChunk = (_chunk, _callback) => {\n      const chunkSize = Buffer.byteLength(_chunk);\n      let chunkRemainder = null;\n      let maxChunkSize = readableHighWaterMark;\n      let bytesLeft;\n      let passed = 0;\n\n      if (maxRate) {\n        const now = Date.now();\n\n        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {\n          internals.ts = now;\n          bytesLeft = bytesThreshold - internals.bytes;\n          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;\n          passed = 0;\n        }\n\n        bytesLeft = bytesThreshold - internals.bytes;\n      }\n\n      if (maxRate) {\n        if (bytesLeft <= 0) {\n          // next time window\n          return setTimeout(() => {\n            _callback(null, _chunk);\n          }, timeWindow - passed);\n        }\n\n        if (bytesLeft < maxChunkSize) {\n          maxChunkSize = bytesLeft;\n        }\n      }\n\n      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {\n        chunkRemainder = _chunk.subarray(maxChunkSize);\n        _chunk = _chunk.subarray(0, maxChunkSize);\n      }\n\n      pushChunk(_chunk, chunkRemainder ? () => {\n        process.nextTick(_callback, null, chunkRemainder);\n      } : _callback);\n    };\n\n    transformChunk(chunk, function transformNextChunk(err, _chunk) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (_chunk) {\n        transformChunk(_chunk, transformNextChunk);\n      } else {\n        callback(null);\n      }\n    });\n  }\n}\n\nexport default AxiosTransformStream;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}